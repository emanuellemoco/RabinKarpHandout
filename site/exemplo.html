<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <title>Algoritmo de Rabin Karp</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Sans+Extra+Condensed:700|Oxygen+Mono|Source+Sans+Pro:700|Source+Serif+Pro&display=swap">
    <link rel="stylesheet" href="assets/css/reset.css">
    <link rel="stylesheet" href="assets/css/style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <script src="assets/js/jquery.js"></script>
    <script src="assets/js/script.js"></script>
  </head>
  <body>
    <div class="container">
      <main>

<h1>Algoritmo de Rabin Karp</h1>

<h2>Introdução</h2>

<p>Você já sabe um jeito básico para procurar padrão em strings, vamos relembrar:  </p>

<pre class="prettybox"><code class="prettyprint">def stringMatching(text, pattern):
    indexes = []
    for i in range(len(text)):
        if text[i:(len(pattern)+i)] == pattern:
            indexes.append(i)
    return indexes</code></pre>

<p>Já sabemos que essa maneira não é ideal pois tem complexidade \(O(nm)\) e como vocês viram há outras maneiras mais eficientes de solucionar este problema, vamos implementar mais uma forma.  </p>

<h2>Questão 1</h2>

<p>Antes de iniciarmos com o algoritmo, é importante falarmos um pouco sobre <strong><em>hashing</em></strong>, pois ele é essêncial para o funcionamento dessa busca. Apenas como aquecimento, discuta com seus colegas se algum de vocês ja ouviu falar sobre este tema.<br/>Coisa rapida, levem cerca de 2 minutos e sigam em frente.</p>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<h2>Hashing</h2>

<p><strong><em>Hashing</em></strong> é um processo que gera uma saída de um valor a partir de uma entrada com tamanho variável. Essa entrada pode ser tanto números quanto caracteres. O valor da saída é conhecido como <strong><em>Hash Value</em></strong> e para chegarmos nesse valor utilizamos uma função, chamada de <em>Hashing function</em>. Essa função pode ser implementada de diversas maneiras, porém mais para frente você vai entender o porquê o tipo de implementação é importante.</p>

<p>Para calcular um <strong><em>Hash Value</em></strong> é utilizado os valores da tabela ASCII respectivos para cada caracter. Você pode acessar a tabela ASCII <a href="https://jeffersonpalheta.files.wordpress.com/2017/09/ascii.png" target="_blank">aqui</a>.</p>

<h2>Questão 2</h2>

<p>Uma maneira para se obter o <em>hash Value</em> é simplesmente somar o valor da tabela ASCII referente a cada caracter. Vamos ver se você entendeu? Calcule o <em>hash Value</em> da palavra <code class="prettybox prettyprint">HASH</code>.</p>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<pre class="prettybox"><code class="prettyprint">72 + 65 + 72 + 83 = 292</code></pre>

<h2>Questão 3</h2>

<p>Agora que vc entendeu como funciona, tente pensar em como implementar essas mudanças no código que você viu acima para comparar os <em>hash Value</em> ao invés de comparar caracter por caracter.</p>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<p>Você deve ter chegado em algo parecido com isso:</p>

<pre class="prettybox"><code class="prettyprint">def stringSearchHash(text, pattern):
    indexes = []

    pattern_value= 0
    for character in pattern:
        pattern_value += ord(character)
    for i in range(len(text)):
        j=i
        text_value = 0
        if (i+len(pattern)&gt;len(text)):
            break
        while(j&lt;i+len(pattern)):
            text_value+=ord(text[j])
            j+=1
        if (text_value==pattern_value):
            indexes.append(i)

    return indexes</code></pre>

<h2>Questão 4</h2>

<p>Essa <em>Hashing function</em> pode, eventualmente, gerar um problema. Você consegue pensar em qual é? Reflita um pouquinho antes de continuar.  </p>

<blockquote><p>DICA: <br/>Simule as funções acima com as entradas:<br/>text: &quot;O MARCELO HASHIMOTO ESTÁ INDO NA PADARIA PDCM, ALGÚEM QUER ALGO?&quot;<br/>pattern: &quot;HASH&quot;  </p></blockquote>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<h2>Colisão</h2>

<p>Notou algum problema? Esse caso é o que chamamos de <em>colisão</em>. Uma colisão ocorre quando duas ou mais entradas têm o mesmo hash value. No exemplo acima, tanto <code class="prettybox prettyprint">HASH</code> como <code class="prettybox prettyprint">PDCM</code> tem o mesmo hash value. <strong>Todas</strong> as funções têm chances de ocorrer colisão, mas algumas funções tem uma menor probabilidade do que outras. Uma <em>boa</em> hash function diminui ao máximo o número de colisões.<br/>Nesta aula utilizaremos a seguinte lei para a função de hashing:</p>

<p>\(Value = R.X_1^{N-1} + R.X_2^{N-1} + R.X_3^{N-2} + ...  + R.X_N^0\)</p>

<p>Onde:</p>

<ul><li>N é a quantidade de caracteres do padrão calculado.</li><li>X é o valor do caracter na tabela ASCII</li><li>R é a quantidade de caracteres do alfabeto utilizado, por exemplo R = 256 para o alfabeto ASCII estendido.  </li></ul>

<p>O código abaixo calcula os valores de hash diminuindo a possibilidade de colisões entre padrão e texto, conforme a formula mostrada acima e considerando R = 256. </p>

<pre class="prettybox"><code class="prettyprint">def stringSearchgHash(text, pattern):
    indexes = []

    pattern_value= 0
    r = 256**(len(pattern)-1)
    for character in pattern:
        pattern_value += ord(character) * r
        r/=256
    for i in range(len(text)):
        if (i+len(pattern)&gt;len(text)):
            break
        j=i
        text_value = 0
        r = 256**(len(pattern))
        while(j&lt;i+len(pattern)):
            text_value+=ord(text[j]) * r
            j+=1
            r/=256
        if (text_value==pattern_value):
            indexes.append(i)

    return indexes</code></pre>

<h2>Usando o Hashing</h2>

<p>Agora que <em>hash</em> é algo além de uma palavra legal da computação, podemos seguir com o algoritimo desse encontro. O Rabin-Karp consiste em iterar com o hash value do padrão sobre o hash de cada parte do texto inteiro, como exemplificado na animação abaixo:</p>

<p class="figure"><img alt="simulacao1" src="img/simulacao1.gif" title="simulacao1" class="raster"/></p>

<p>Mas essa solução também tem um problema! É necessário acessar vários caracteres múltiplas vezes para pegar o seu valor. Como é possível observar na simulação acima, primeiro é calculado o valor de <code class="prettybox prettyprint">ADA</code>, ou ,seja o valor de <code class="prettybox prettyprint">A</code> + <code class="prettybox prettyprint">D</code> + <code class="prettybox prettyprint">A</code>, na proxima iteração, é calculado do valor de <code class="prettybox prettyprint">DAC</code>, ou seja, <code class="prettybox prettyprint">D</code> + <code class="prettybox prettyprint">A</code> + <code class="prettybox prettyprint">C</code> porém, o valor de <code class="prettybox prettyprint">D</code> e <code class="prettybox prettyprint">A</code> que já foi calculado na primeira iteração, é recalculado para a segunda. Fazendo o código dessa maneira ainda gera uma complexidade ruim de \(O(nm)\) </p>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<h2>Rolling Hash</h2>

<p>A correção para melhorar a complexidade, do algoritmo, é a aplicação do método <em>Rolling Hash</em> que consiste em manter a maior parte dos números já calculados, evitando o desperdício de tempo e memória que seria recalcula-los. Por exemplo, após o primeiro cálculo do valor de Hash, basta subtrair o valor do primeiro carácter comparado e adicionar o do próximo carácter.
Esta função pode ser visualizada na animação abaixo:  </p>

<p class="figure"><img alt="simulacao2" src="img/simulacao2.gif" title="simulacao2" class="raster"/></p>

<p>Como é possíver perceber na animação, primeiro é calculado o valor de <code class="prettybox prettyprint">ADA</code> com os valores de <code class="prettybox prettyprint">A</code> + <code class="prettybox prettyprint">D</code> + <code class="prettybox prettyprint">A</code>. Na iteração seguinte é calculado o valor de <code class="prettybox prettyprint">DAC</code>, porém utiliza os valores já calculados de <code class="prettybox prettyprint">D</code> + <code class="prettybox prettyprint">A</code> e subtrai o valor também já calculado de <code class="prettybox prettyprint">A</code> (destacado em vermelho), sendo assim, só é necessário calcular e adicionar o valor do proximo caracter, no caso o <code class="prettybox prettyprint">C</code>.
<img alt="complexidade" src="complexidade.png"/>  </p>

<pre class="prettybox"><code class="prettyprint">def RollingHash(text, pattern):
    indexes = []

    m = len(text)
    n = len(pattern)

    pattern_value = 0
    text_value =0
    r = 10**(len(pattern)-1)
    for i in range(len(pattern)):
        pattern_value+= ord(pattern[i]) * r
        text_value+= ord(text[i]) * r 
        r/= 10
    if (pattern_value==text_value):
        indexes.append(i-n+1)
    for i in range(n,m):
        text_value = (text_value - ord(text[i-n])*10**(n-1))*10 + ord(text[i])
        if (pattern_value==text_value):
            indexes.append(i-n+1)
    return indexes  </code></pre>

<h2>Questão 4</h2>

<p>Qual é a complexidade desse código?  </p>

<h2>Rabin-Karp</h2>

<p>O grande diferencial do algoritmo de Rabin-Karp que procura por um segmento de texto que tenha o mesmo <em>hash value</em> do padrão, é o fato do mesmo utilizar o método de <em>rolling hash</em>, permitindo assim que ele tenha sua complexidade reduzida à \(O(n+m)\) no melhor médio, tornando-o mais eficiente do que algoritimos triviais de complexidade \(O(nm)\). </p>

<p>Existem dois tipos de implementação desse algoritmo, o método de <strong>Monte Carlo</strong> e de <strong>Las Vegas</strong>. A primeira assume que não há nenhuma colisão durante a comparação. Quando o hash value do fragmento do texto bate com o do padrão, nenhuma comparação de caracteres é feita, por isso sua complexidade é \(O(n+m)\) em todos os casos. Já a de <em>Las Vegas</em> checa se os caracteres são realmente os mesmos, mas isso significa que em um caso em que todos os fragmentos de texto analisados têm o mesmo hash value do padrão, o código tem que realizar a comparação de caracteres <em>n</em> vezes, tornando a complexidade em \(O(nm)\) no seu pior caso.</p>

<p>As comparações de complexidade entre as implementações mencionadas podem ser vistas na tabela abaixo.  </p>

<p class="figure"><img alt="complexidade" src="img/complexidade.png" title="complexidade" class="raster"/>  </p>

<h2>Sobre o algoritmo</h2>

<p>O Rabin-Karp pode ser utilizado como uma ferramenta de busca simples, porém onde ele tem seu valor destacado é dentro de sistemas de plágio, nos quais parágrafos de textos avaliativos ou científicos são colocados no programa como padrão de busca enquanto livros e banco de dados relacionados ao tema são colocados como texto aonde se quer encontrar alguma incidência de cópia indevida. 
Nesses casos, como a entrada é grande, o número de colisões se reduz significamente, pois o hash value fica cada vez mais específico e tendendo à ser único. O que garante que nesse tipo de aplicação o programa atue com seu melhor nivel de complexidade \(O(n+m)\). </p>

<h2>Overflow</h2>

<p>Quando o padrão a ser calculado é muito grande, pode ocorrer problema de overflow. Para contornar isso, o algoritmo de Rabin-Karp utiliza <em>hashing modular</em>.<br/>Ou seja, toda vez que um valor de hash é calculado, é feito o modulo desse valor por Q (\(Value = Value % Q 0\)), onde Q é um inteiro maior que R (quantidade de caracteres do alfabeto utilizado). Para evitar colisões é interessante que o valor Q seja um número primo.
Abaixo temos o exemplo de um fórmula para cálcular um hash value utilizando modulação e técnicas para diminuir a possibilidade de colisões.</p>

<p>\(Value = ((R . X_{i-1}\) % \(Q + t_{i-1}(Q-R^{M-1} \)%\(Q)).R + t_{1+M-1} A Q )\)</p>

      </main>
      <footer>
        <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
          <img alt="Creative Commons Attribution-ShareAlike 4.0 International License" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" title="Creative Commons Attribution-ShareAlike 4.0 International License"/>
        </a>
        © 2020 Desafios de Programação
      </footer>
    </div>
  </body>
</html>
